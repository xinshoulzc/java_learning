#GC(Garbage Collection):

##1.引用计数收集器  reference counting collector

引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象（不是引用）都有一个引用计数。当一个对象被创建时，且将该对象分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象+1），但当一个对象的某个引用超过了生命周期或者被设置为一个新值时，对象的引用计数减1。任何引用计数为0的对象可以被当作垃圾收集。当一个对象被垃圾收集时，它引用的任何对象计数减1。

> 优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序不被长时间打断的实时环境比较有利。
> 缺点： 无法检测出循环引用。如A对象有一个B对象的引用，B对象反过来引用A对象。这样，他们的引用计数永远不可能为0.
> > In following codes, intro to circular reference

```java
    class Company {
        public List<string> Employeer;
    }
    class Employeer{
        public List<string> Company;
    }
```

##2.跟踪收集器

目前主流的虚拟机，如java默认虚拟机HotSpot就是用的这种方式。算法基本思路为：【通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（或者说从GC Roots到这个对象不可达），则证明此对象是不可用的】。
可作为GC Roots的对象包括：
1）虚拟机栈（栈帧中的本地变量表）中引用的对象；
2）方法区中类静态static属性引用的对象；
3）方法区中常量final引用的对象；
4）本地方法栈中JNI（即一般说的Native方法）引用的对象；

需要注意的是，即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（也就是说对象的finalize()方法只能被调用一次），虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它（即去执行对象的finalize()方法，这里所谓的“执行”是值虚拟机会触发这个方法，但并不承若会等待它运行结束，主要是为了防止对象的finalize方法执行缓慢或发生死循环，导致其他对象不能被执行的，从而引起内存回收系统崩溃）。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只需要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

因此对于不可达对象判定真正死亡的过程小结如下：（1）GC进行第一次标记并进行一次筛选（筛选那些覆盖了finalize方法并且finalize方法是第一次调用的对象）；--> （2）另一个低优先级的线程去调用那些被筛选出来的对象的finalize方法；--> （3）GC进行第二次标记，如果在前一步中那些筛选出来的对象没有在finalize拯救自己，此时，那些未被筛选到的和这些这些筛选到的但是没有拯救自己的对象都将会回收。